# Description

This contains an implementation of an algorithm to exhaustively find all perfect sequences over the quaternion alphabet of {±1, ±i, ±j, ±k, ±q, ±qi, ±qj, ±qk} where q = (1+i+j+k)/2.
The algorithm is written in Rust, and it is accessible through shell scripts.

## How to run

* `driver.sh` compiles the code and runs the algorithm described in our paper _Quaternionic Perfect Sequences and Hadamard Matrices_ to exhaustively generate sequences of the desired length. Results will be stored in /rust/results/pairs/`<sequencetype>`/find_`<length>`/
Usage: `./driver.sh <sequencetype> <length> [flags]`
    * `sequencetype` is the type of sequence to be searched for. Options are wts (Williamson-type sequences), qts (QT sequences), or ws (Williamson sequences). The algorithm is optimized for Williamson-type sequences (and we prove these are equivalent to QT sequences).
    * `length` is the length 
    * Flags:
        * `-d`: Delete existing .seq, .pair and .sorted files before running
        * `-h`: Convert sequences to Hadamard matrices when finished
        * `-c`: Use auto/cross correlation for matching instead of PSD/CPSD
        * `-s`: Use this flag for SLURM jobs
        * `-p <pairing>`: Specify rowsum pairing to be used. Options include WX, WY and WZ (e.g., WX means that the sequences of rowsum W are paired with the sequences of rowsum X). Note that the code follows the convention W <= X <= Y <= Z. Default is WZ  
* `collect_results.py` generates a summary of a completed computation in a table. Run with no arguments to see required parameters. **NOTE:** If sequences have not been reduced to Hadamard equivalence, the corresponding part of the table will be recorded as -1.
* `pair_file_cleanup.sh` removes the `.pair` (and related) files from the `/find_n` directories. These can take up a lot of disk space for large lengths, especially in qts mode. In wts mode, amicability filtering is used which dramatically reduces the amount of disk space.

The different parts of the algorithm run by `driver.sh` can also be run one at a time via the following scripts, which must be run in the following order:
1. `pairs.sh` generates all of the `.pair` files
2. `sortpairs.sh` sorts the `.pair` files
3. `join_pairs.sh` matches the data in the `.pair` files to find valid sequences, and reduces them to sequence equivalence
4. `convert_hm.sh` converts the matched sequences found in the previous step to Hadamard matrices up to Hadamard equivalence

All scripts can be run without arguments to get a message describing how to use them.

### Output files
Any and all output generated by these scripts that is not written to `stdout` is written to the following files in `/rust/results/pairs/sequencetype/find_n/`:
* `result.log` contains the output log from a computation, which mostly mirrors the output sent to `stdout`
* `result.mat` contains any generated Hadamard matrices
* `result.seq` contains the final generated sequences up to equivalence in the form of quaternion sequences according to our [encoding](#quaternion-encoding)
* `result.qseq` contains the final generated sequences up to equivalence in the form of quadruples of binary sequences
* `rowsum_w_x_y_z/` contains the exhaustive enumeration of binary sequences to match the rowsums $(w,x,y,z)$, as well as the `.pair` files

# Layout of the code

## In the rust folder:

The `rust` folder contains the implementation for the algorithm described in our paper.

### The `src` folder contains all of the code 

The `find` folder contains the code that finds and generates specific sequences.

The `sequences` folder contains the code for the classes related to Williamson-type and QT sequences.

The `test` folder contains tests of various parts of the code.
You can run the tests with the command `cargo test`.

### Quaternion encoding

The Williamson-type and QT sequences are represented in the following format:
each line contains a sequence, and each element corresponds to a character

| Quaternion | Encoding |
| :--------: | :------: |
| $1$        | `+`      |
| $-1$       | `-`      |
| $i$        | `i`      |
| $j$        | `j`      |
| $k$        | `k`      |
| $q$        | `q`      |
| $qi$       | `x`      |
| $qj$       | `y`      |
| $qk$       | `z`      |

with $q=\frac{1+i+j+k}{2}$.

The negatives of these quaternions (except $1$ and $-1$) are represented by capital letters instead.
For example, $-qi \rightarrow$`X`

### The `src/find` folder

The `src/find` folder contains all the code that enumerates sequences.

`find_naive`, `find_optim`, `find_unique` and `find_williamson` are all variations of the naive approach: brute-forcing the sequences.

`find_with_rowsum` is an approach using a solver that was too slow for what we were aiming for.

`find_write` contains the code of the efficient algorithm that we explain in our paper.
